package main

import "fmt"

/** 题解
	这道题使用桶排序的思路，即 “一个萝卜一个坑”。在学习“排序算法”的时候，可能会忽略“桶排序”的作用，但它的思想的确可以解决一些特定问题。

	  “桶排序”的思想，有些地方也把它叫做“抽屉原理”，以下介绍来自“百度百科”之“抽屉原理”词条：
	抽屉原理的一般含义为：“如果每个抽屉代表一个集合，每一个苹果就可以代表一个元素，
	假如有 n + 1 个元素放到 n 个集合中去，其中必定有一个集合里至少有两个元素。”抽屉原理有时也被称为鸽巢原理。它是组合数学中一个重要的原理。

	桶排序思想：以示例输输入[3,4,-1,1] 为例：
			首先看索引0 上的数字
			-------------------
			|  3 | 4 | -1 | 1 |      在索引 0 上的数字3,它应该放在索引2上，因此索引0 与索引 2 交换.
			-------------------

			接下看索引0 上的数字
			-------------------
			|  -1 | 4 | 3Y | 1 |      在索引 2 现在防止的数字是3放对了，我们把它后边标Y
			-------------------				现在索引 0 上的数字是 -1 ,它不在{1,2,3,4} 这个集合中，是“无处安放”的元素，放在哪里都不对，索引0上的元素等待后续如果有数字1会被交换过来，截下来看下一个索引

			首先看索引1 上的数字
			-------------------
			|  -1 | 4 | 3Y | 1 |       在索引 1 上的数字4,它应该放在索引3上，因此索引1 与索引 3 交换.
			-------------------

				接下看索引1 上的数字
			-------------------
			|  -1 | 1 | 3Y | 4Y |      在索引 3 现在防止的数字是4 放对了，我们把它后边标Y
			-------------------				 索引 1 上现在放数字是 1 ,它应该被放在索引0处，因此将所引0与索引1交换。

			接下看索引1 上的数字
				-------------------			在索引 0 现在防止的数字是1 放对了，我们把它后边标Y
			|  1Y | -1 | 3Y | 4Y |     索引 1 上现在放数字是 -1 ,按着之前的分析，它不再{1,2,3,4}，这个集合中，是“无处安放”的元素，放在哪里都不对，
			-------------------				 索引1上的元素等待后续如果有数字2会被交换过来，截下来看下个索引

				接下看索引2 上的数字
				-------------------			在索引 2 现在放置的数字是3 ，截下来看下个索引
			|  1Y | -1 | 3Y | 4Y |
			-------------------

					接下看索引3 上的数字
				-------------------			在索引 3 现在放置对的数字是4，此时任务桶排序已经完成。
			|  1Y | -1 | 3Y | 4Y |    现在需要从头到尾看一遍，找出第一个“最不和谐”的元素的索引+1即可返回，
			-------------------				从左到右第一个不被标红的数是-1，他的索引是1，因此“缺失"的第一个数字就是2

**/

func firstMissingPositive(nums []int) int {
	nlen := len(nums)
	for i := 0; i < nlen; i++ {
		for nums[i] != i+1 {
			if nums[i] <= 0 || nums[i] > nlen || nums[i] == nums[nums[i]-1] {
				break
			}
			// 将nums[i] 放置到对应位置上[1,2,3,4....]
			idx := nums[i] - 1
			nums[i] = nums[idx]
			nums[idx] = idx + 1
		}
	}
	for i, n := range nums {
		if n != i+1 {
			return i + 1
		}
	}
	return nlen + 1
}

func main() {
	arr := []int{2, 3, 5}
	num := firstMissingPositive(arr)
	fmt.Println(num)
}

/*
	给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

	示例 1:

	输入: [1,2,0]
	输出: 3
	示例 2:

	输入: [3,4,-1,1]
	输出: 2
	示例 3:

	输入: [7,8,9,11,12]
	输出: 1
	说明:

	你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间
*/
